void begin(void* a);
void start(void* a)
{
	begin(a);
}
char _STR353E_0MAI[] = ".";
char _STR57E0_1MAI[] = "..";
char _STRB352_2MAI[] = "/";
char _STRE30F_3MAI[] = "Couldn't open base path.\n";
char _STRD0CF_4MAI[] = ".";
char _STRCF4B_5MAI[] = "..";
char _STR208_6MAI[] = "/";
char _STR895A_7MAI[] = "/";
char _STR1733_8MAI[] = "%s -> %s\n";
char _STRDBAC_9MAI[] = "COULD NOT CREATE";
char _STRD2E5_AMAI[] = "rb";
char _STR48DD_BMAI[] = "COULD NOT COPY";
char _STRF92C_CMAI[] = "COULD NOT COPY";
char _STR8A1_DMAI[] = "NO MEMORY";
char _STR32AE_EMAI[] = "C:/Users/";
char _STR669_FMAI[] = "/Desktop";
char _STR9EC7_10MAI[] = "C:/Users/";
char _STRAE76_11MAI[] = "/Documents";
char _STRD4E4_12MAI[] = "C:/Users/";
char _STRC54C_13MAI[] = "/Downloads";
char _STRA327_14MAI[] = "C:/Users/";
char _STR98A7_15MAI[] = "/Photos";
char _STR62AD_16MAI[] = "C:/Users/";
char _STRD5AB_17MAI[] = "/Trash Bin";
char _STR44A8_18MAI[] = "C:/Users/";
char _STRD780_19MAI[] = "/Music";
char _STRD7C2_1AMAI[] = "C:/Users/";
char _STRE8C7_1BMAI[] = "/Movies";
char _STR1E2C_1CMAI[] = "C:/Banana/Registry/User/";
char _STRC07C_1DMAI[] = "C:/Banana/Registry/DefaultUser";
char _STR4B1F_1EMAI[] = "Setting up the system for the first time";
char _STR4CD2_1FMAI[] = "C:/Banana/Registry/System";
char _STR9035_20MAI[] = "C:/Banana/Registry/User";
char _STR3B18_21MAI[] = "C:/Banana/Registry/System";
char _STR2758_22MAI[] = "C:/Banana/Registry/User";
char _STRC70B_23MAI[] = "C:/Banana/Registry/DefaultSystem";
char _STR5D61_24MAI[] = "C:/Banana/Registry/System";
char _STR4CE5_25MAI[] = "Alex";
char _STR9883_26MAI[] = "Loading extensions";
char _STRE0D4_27MAI[] = "C:/Banana/System/setupisd.one";
char _STR667D_28MAI[] = "SYSINIT FAILURE";
char _STRA246_29MAI[] = "THIS IS THE FIRST RUN!!!\n";
char _STR256B_2AMAI[] = "shell";
char _STR832B_2BMAI[] = "playJingle";
char _STR7DBE_2CMAI[] = "Alex";
char _STR3776_2DMAI[] = "C:/Banana/System/command.exe";
char _STR78C2_2EMAI[] = "call";
char _STR60C6_2FMAI[] = "C:/Banana/System/init.bat";
char _STRDC4_30MAI[] = "C:/Banana/System/command.exe";
char _STR2C68_31MAI[] = "C:/Banana/System/command.exe";
char _STR577E_32MAI[] = "shell";
char _STR7D9A_33MAI[] = "autogui";
char _STR63DC_34MAI[] = "AUTO GUI.\n";

#include <stdint.h>


#include "main.hpp"

#include "core/main.hpp"
#include "core/computer.hpp"
#include "thr/elf.hpp"
#include "core/terminal.hpp"
#include "core/physmgr.hpp"
#include "reg/registry.hpp"
#include "thr/prcssthr.hpp"
#include "hal/buzzer.hpp"
#include "fs/vfs.hpp"

//MAIN SCRIPT


#define ACPI_SIZE size_t

int
memcmp(
    void* VBuffer1,
    void* VBuffer2,
    ACPI_SIZE               Count)
{
    char* Buffer1 = (char*) VBuffer1;
    char* Buffer2 = (char*) VBuffer2;


    for (; Count-- && (*Buffer1 == *Buffer2); Buffer1++, Buffer2++) {
    }

    return ((Count == ACPI_SIZE_MAX) ? 0 : ((unsigned char) *Buffer1 -
            (unsigned char) *Buffer2));
}

void*
memmove(
    void* Dest,
    const void* Src,
    ACPI_SIZE               Count)
{
    char* New = (char*) Dest;
    char* Old = (char*) Src;


    if (Old > New) {
        while (Count) {
            *New = *Old;
            New++;
            Old++;
            Count--;
        }
    } else if (Old < New) {
        New = New + Count - 1;
        Old = Old + Count - 1;
        while (Count) {
            *New = *Old;
            New--;
            Old--;
            Count--;
        }
    }

    return (Dest);
}


#include <stdint.h>
#include <stddef.h>


void*
memset(
    void* Dest,
    int                     Value,
    ACPI_SIZE               Count)
{
    char* New = (char*) Dest;


    while (Count) {
        *New = (char) Value;
        New++;
        Count--;
    }

    return (Dest);
}


ACPI_SIZE
strlen(
    const char* String)
{
    UINT32                  Length = 0;


    while (*String) {
        Length++;
        String++;
    }

    return (Length);
}


char*
strpbrk(
    const char* String,
    const char* Delimiters)
{
    const char* Delimiter;


    for (; *String != '\0'; ++String) {
        for (Delimiter = Delimiters; *Delimiter != '\0'; Delimiter++) {
            if (*String == *Delimiter) {
                return (ACPI_CAST_PTR(char, String));
            }
        }
    }

    return (NULL);
}

char* SavedPtr;
char*
strtok(
    char* String,
    const char* Delimiters)
{
    char* Begin = String;


    if (Begin == NULL) {
        if (SavedPtr == NULL) {
            return (NULL);
        }
        Begin = SavedPtr;
    }

    SavedPtr = strpbrk(Begin, Delimiters);
    while (SavedPtr == Begin) {
        *Begin++ = '\0';
        SavedPtr = strpbrk(Begin, Delimiters);
    }

    if (SavedPtr) {
        *SavedPtr++ = '\0';
        return (Begin);
    } else {
        return (NULL);
    }
}

char*
strcpy(
    char* DstString,
    const char* SrcString)
{
    char* String = DstString;

    while (*SrcString) {
        *String = *SrcString;

        String++;
        SrcString++;
    }

    *String = 0;
    return (DstString);
}

char*
strncpy(
    char* DstString,
    const char* SrcString,
    ACPI_SIZE               Count)
{
    char* String = DstString;


    for (String = DstString;
         Count && (Count--, (*String++ = *SrcString++)); ) {
        ;
    }

    while (Count--) {
        *String = 0;
        String++;
    }

    return (DstString);
}

int
strcmp(
    const char* String1,
    const char* String2)
{


    for (; (*String1 == *String2); String2++) {
        if (!*String1++) {
            return (0);
        }
    }

    return ((unsigned char) *String1 - (unsigned char) *String2);
}

char*
strchr(
    const char* String,
    int                     ch)
{


    for (; (*String); String++) {
        if ((*String) == (char) ch) {
            return ((char*) String);
        }
    }

    return (NULL);
}

int
strncmp(
    const char* String1,
    const char* String2,
    ACPI_SIZE               Count)
{


    for (; Count-- && (*String1 == *String2); String2++) {
        if (!*String1++) {
            return (0);
        }
    }

    return ((Count == ACPI_SIZE_MAX) ? 0 : ((unsigned char) *String1 -
            (unsigned char) *String2));
}

char*
strcat(
    char* DstString,
    const char* SrcString)
{
    char* String;

    for (String = DstString; *String++; ) {
        ;
    }

    for (--String; (*String++ = *SrcString++); ) {
        ;
    }

    return (DstString);
}

char*
strncat(
    char* DstString,
    const char* SrcString,
    ACPI_SIZE               Count)
{
    char* String;


    if (Count) {
        for (String = DstString; *String++; ) {
            ;
        }

        for (--String; (*String++ = *SrcString++) && --Count; ) {
            ;
        }

        if (!Count) {
            *String = 0;
        }
    }

    return (DstString);
}


char*
strstr(
    char* String1,
    char* String2)
{
    ACPI_SIZE               Length;


    Length = strlen(String2);
    if (!Length) {
        return (String1);
    }

    while (strlen(String1) >= Length) {
        if (memcmp(String1, String2, Length) == 0) {
            return (String1);
        }
        String1++;
    }

    return (NULL);
}


void rmtree(char* basePath)
{
	char path[300];
	memset(path, 0, 300);

	struct dirent _dp;
	struct dirent* dp = &_dp;

	int br;
	Directory* dir = new Directory(basePath, currentTaskTCB->processRelatedTo);
	FileStatus openstatus = dir->open();
	
	if (openstatus != FileStatus::Success) {
		delete dir;
		return;
	}

	while (1) {
		FileStatus st = dir->read(sizeof(struct dirent), dp, &br);
		if (st != FileStatus::Success) {
			break;
		}

		if (strcmp(dp->d_name, _STR353E_0MAI) != 0 && strcmp(dp->d_name, _STR57E0_1MAI) != 0) {
			if (dp->d_type & DT_DIR) {
				rmtree(path);
			} else {
				strcpy(path, basePath);
				strcat(path, _STRB352_2MAI);
				strcat(path, dp->d_name);

				File* f = new File(path, currentTaskTCB->processRelatedTo);
				f->unlink();
				delete f;
			}
		}
	}

	dir->close();
	dir->unlink();
	delete dir;
}

int mkdir(const char* path, int permissions)
{
    Directory* d = new Directory(path, kernelProcess);
    d->create();
    delete d;

    return 0;
}

void copytree(char* basePath, char* newPath)
{
	char* path = (char*) malloc(400);
	char* npath = (char*) malloc(400);
    memset(path, 0, 400);
    memset(npath, 0, 400);

    struct dirent _dp;
    struct dirent* dp = &_dp;
	
    int br;
    Directory* dir = new Directory(basePath, currentTaskTCB->processRelatedTo);
    FileStatus openstatus = dir->open();
    if (openstatus != FileStatus::Success) {
        kprintf(_STRE30F_3MAI);
        delete dir;
        return;
    }

	while (1) {
        FileStatus st = dir->read(sizeof(struct dirent), dp, &br);
		if (st != FileStatus::Success) {
			break;
		}

		if (strcmp(dp->d_name, _STR353E_0MAI) != 0 && strcmp(dp->d_name, _STR57E0_1MAI) != 0) {
			strcpy(path, basePath);
			strcat(path, _STRB352_2MAI);
			strcat(path, dp->d_name);

			strcpy(npath, newPath);
			strcat(npath, _STRB352_2MAI);
			strcat(npath, dp->d_name);

            kprintf(_STR1733_8MAI, path, npath);
            
			if (dp->d_type & DT_DIR) {
				int mres = mkdir(npath, 0700);
				if (mres != 0) {
					panic(_STRDBAC_9MAI);
				} else {
					copytree(path, npath);
				}

			} else {
				File* f = new File(path, currentTaskTCB->processRelatedTo); //fopen(path, _STRD2E5_AMAI);
                f->open(FILE_OPEN_READ);
				if (!f) {
					panic(_STR48DD_BMAI);
					continue;
				}

				if (f) {
                    File* dest = new File(npath, currentTaskTCB->processRelatedTo);
                    f->open(FILE_OPEN_WRITE_NORMAL);
					if (!dest) {
						panic(_STR48DD_BMAI);
                        f->close();
						continue;
					}

					char* m = (char*) malloc(4096);
					if (!m) {
						panic(_STR8A1_DMAI);
						free(path);
						free(npath);
						return;
					}
					while (1) {
                        //read(uint64_t bytes, void* where, int* bytesRead)

                        int red;
                        int red2;
                        FileStatus st = f->read(4096, m, &red);
                        if (st != FileStatus::Success) {
                            break;
                        }
                        f->write(red, m, &red2);
                        if (red != 4096) {
                            break;
                        }
					}
					free(m);

                    f->close();
                    dest->close();
                    delete f;
                    delete dest;
				}
			}
		}
	}

	free(path);
	free(npath);

	dir->close();
    delete dir;
}

void createUser(const char* name)
{
    char path[256];
    strcpy(path, _STR32AE_EMAI);
    strcat(path, name);
    mkdir(path, 0700);
    
    strcat(path, _STR669_FMAI);
    mkdir(path, 0700);

    strcpy(path, _STR32AE_EMAI);
    strcat(path, name);
    strcat(path, _STRAE76_11MAI);
    mkdir(path, 0700);

    strcpy(path, _STR32AE_EMAI);
    strcat(path, name);
    strcat(path, _STRC54C_13MAI);
    mkdir(path, 0700);

    strcpy(path, _STR32AE_EMAI);
    strcat(path, name);
    strcat(path, _STR98A7_15MAI);
    mkdir(path, 0700);

    strcpy(path, _STR32AE_EMAI);
    strcat(path, name);
    strcat(path, _STRD5AB_17MAI);
    mkdir(path, 0700);

    strcpy(path, _STR32AE_EMAI);
    strcat(path, name);
    strcat(path, _STRD780_19MAI);
    mkdir(path, 0700);

    strcpy(path, _STR32AE_EMAI);
    strcat(path, name);
    strcat(path, _STRE8C7_1BMAI);
    mkdir(path, 0700);

    strcpy(path, _STR1E2C_1CMAI);
    strcat(path, name);
    mkdir(path, 0700);

    copytree(_STRC07C_1DMAI, path);
}

void firstRun()
{
	computer->setBootMessage(_STR4B1F_1EMAI);

	rmtree(_STR4CD2_1FMAI);
	rmtree(_STR9035_20MAI);
	mkdir(_STR4CD2_1FMAI, 0700);
	mkdir(_STR9035_20MAI, 0700);
	copytree(_STRC70B_23MAI, _STR4CD2_1FMAI);

    createUser(_STR4CE5_25MAI);
}

void loadExtensions()
{
	computer->setBootMessage(_STR9883_26MAI);
}

void playJingle(void* context)
{
    unlockScheduler();

    systemBuzzer->beep(131, 400);
    systemBuzzer->beep(175, 400);
    systemBuzzer->beep(247, 400);
    systemBuzzer->beep(330, 400);
    systemBuzzer->beep(440, 400);
    systemBuzzer->beep(587, 400);
    systemBuzzer->beep(784, 400);
    systemBuzzer->beep(698, 400);
    systemBuzzer->beep(659, 800);
    systemBuzzer->stop();

    terminateTask(0);
}

void begin(void* a)
{
    bool firstTime = false;

    File* f = new File(_STRE0D4_27MAI, kernelProcess);
    if (!f) {
        panic(_STR667D_28MAI);
    }
    FileStatus fs = f->open(FileOpenMode::Read);

    if (fs == FileStatus::Success) {
        f->close();
    } else {
        firstTime = true; 
    }
    delete f;

    if (firstTime) {
        kprintf(_STRA246_29MAI);
        //firstRun();

    } else {
        if (Reg::readBoolWithDefault(_STR256B_2AMAI, _STR832B_2BMAI, true)) {
            //kernelProcess->createThread(playJingle);
        }        

        loadExtensions();
    }

    VgaText::hiddenOut = false;
    Krnl::preemptionOn = true;

    Process* usertask;
    
    if (firstTime) {
        //createUser(_STR4CE5_25MAI);
        char* argv[] = { _STR3776_2DMAI, _STR78C2_2EMAI, _STR60C6_2FMAI, 0 };
        usertask = new Process(_STR3776_2DMAI, nullptr, argv);
    } else {
        usertask = new Process(_STR3776_2DMAI);
    }
    setActiveTerminal(usertask->terminal);

    usertask->createUserThread();

    int autogui = Reg::readIntWithDefault((char*) _STR256B_2AMAI, (char*) _STR7D9A_33MAI, 0);

    extern void startGUIVESA(void* a);
    if (autogui) {
        kprintf(_STR63DC_34MAI);
        startGUIVESA(nullptr);
    }

    int wstatus;
    waitTask(usertask->pid, &wstatus, 0);

    computer->close(0, 0, nullptr);
}